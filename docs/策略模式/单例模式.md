## 单例模式

> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

```js
var Singleton = function( name ){
 this.name = name;
 this.instance = null;
};
Singleton.prototype.getName = function(){
 alert ( this.name );
};
Singleton.getInstance = function( name ){
 if ( !this.instance ){
 this.instance = new Singleton( name );
 }
 return this.instance;
};
var a = Singleton.getInstance( 'sven1' );
var b = Singleton.getInstance( 'sven2' );
alert ( a === b ); // true 
```

## 惰性单例

> 在合适的时候才创建对象，并且只创建唯一的一个。

```js
var getSingle = function( fn ){
 var result;
 return function(){
 return result || ( result = fn .apply(this, arguments ) );
 }
}; 

var createLoginLayer = function(){
 var div = document.createElement( 'div' );
 div.innerHTML = '我是登录浮窗';
 div.style.display = 'none';
 document.body.appendChild( div );
 return div;
};
var createSingleLoginLayer = getSingle( createLoginLayer );
document.getElementById( 'loginBtn' ).onclick = function(){
 var loginLayer = createSingleLoginLayer();
 loginLayer.style.display = 'block';
};


//===

var bindEvent = getSingle(function(){
 document.getElementById( 'div1' ).onclick = function(){
 alert ( 'click' );
 }
 return true;
});
var render = function(){
 console.log( '开始渲染列表' );
 bindEvent();
};
render();
render();
render(); 
```

