## 策略模式

> 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。就是：定义一系列的算法，把它们各自封装成策略类，算法被 封装在策略类内部的方法里。在客户对 Context 发起请求的时候，Context 总是把请求委托给这些 策略对象中间的某一个进行计算。



**优点**:

- 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。

- 策略模式提供了对开放—封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它

们易于切换，易于理解，易于扩展。

- 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。

- 在策略模式中利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻

便的替代方案。

**缺点**:

- 使用策略模式会在程序中增加许多策略类或者策略对象
- 要使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点，

```js
    var strategies = {
        "S": function (salary) {
            return salary * 4;
        },
        "A": function (salary) {
            return salary * 3;
        },
        "B": function (salary) {
            return salary * 2;
        }
    };
    var calculateBonus = function (level, salary) {
        return strategies[level](salary);
    };
    console.log(calculateBonus('S', 20000)); // 输出：80000
    console.log(calculateBonus('A', 10000)); // 输出：30000 
```





## 缓动算法

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div style="position:absolute;background:blue" id="div">我是 div</div>
</body>
<script>
    var tween = {
        linear: function (t, b, c, d) {
            return c * t / d + b;
        },
        easeIn: function (t, b, c, d) {
            return c * (t /= d) * t + b;
        },
        strongEaseIn: function (t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        },
        strongEaseOut: function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        },
        sineaseIn: function (t, b, c, d) {
            return c * (t /= d) * t * t + b;
        },
        sineaseOut: function (t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        }
    };

    var Animate = function (dom) {
        this.dom = dom; // 进行运动的 dom 节点
        this.startTime = 0; // 动画开始时间
        this.startPos = 0; // 动画开始时，dom 节点的位置，即 dom 的初始位置
        this.endPos = 0; // 动画结束时，dom 节点的位置，即 dom 的目标位置
        this.propertyName = null; // dom 节点需要被改变的 css 属性名
        this.easing = null; // 缓动算法
        this.duration = null; // 动画持续时间
    };

    Animate.prototype.start = function (propertyName, endPos, duration, easing) {
        this.startTime = +new Date; // 动画启动时间
        this.startPos = this.dom.getBoundingClientRect()[propertyName]; // dom 节点初始位置
        this.propertyName = propertyName; // dom 节点需要被改变的 CSS 属性名
        this.endPos = endPos; // dom 节点目标位置
        this.duration = duration; // 动画持续事件
        this.easing = tween[easing]; // 缓动算法
        var self = this;
        var timeId = setInterval(function () { // 启动定时器，开始执行动画
            if (self.step() === false) { // 如果动画已结束，则清除定时器
                clearInterval(timeId);
            }
        }, 19);
    };

    Animate.prototype.step = function () {
        var t = +new Date; // 取得当前时间
        if (t >= this.startTime + this.duration) { // (1)
            this.update(this.endPos); // 更新小球的 CSS 属性值
            return false;
        }
        var pos = this.easing(t - this.startTime, this.startPos,
            this.endPos - this.startPos, this.duration);
        // pos 为小球当前位置
        this.update(pos); // 更新小球的 CSS 属性值
    };

    Animate.prototype.update = function (pos) {
        this.dom.style[this.propertyName] = pos + 'px';
    };

    var div = document.getElementById('div');
    var animate = new Animate(div);
    animate.start('left', 500, 1000, 'strongEaseOut');
    setTimeout(function () {
        animate.start('top', 500, 1500, 'strongEaseIn');
        console.log('1')
    }, 1000)
    setTimeout(function () {
        animate.start('left', 100, 1000, 'strongEaseOut');
        console.log('2')
    }, 2500)
</script>

</html>
```

