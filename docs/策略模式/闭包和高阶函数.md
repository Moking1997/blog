## 闭包

>  闭包可以理解为一个闭包就是一个没有释放资源的栈区，栈区内的变量处于激活状态。

1. 封装变量 闭包可以帮助把一些不需要暴露在全局的变量封装成“私有变量”。

2. 延续局部变量的寿命

   ```js
    var report = (function(){
    var imgs = [];
    return function( src ){
    var img = new Image();
    imgs.push( img );
    img.src = src;
    }
   })(); 
   ```

   

跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作 用域链中保存着一些 DOM 节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非 JavaScript 的问题。

在 IE 浏览器中，由于 BOM 和 DOM 中的对象是使用 C++以 COM 对象 的方式实现的，而 COM 对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用 造成的内存泄露在本质上也不是闭包造成的。

 同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为 null 即可。将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运 行时，就会删除这些值并回收它们占用的内存。



## 高阶函数

- 函数可以作为参数被传递； 

- 函数可以作为返回值输出。

### 函数作为参数传递

1. 回调函数

2. Array.prototype.sort

   ```js
   //从小到大排列
   [ 1, 4, 3 ].sort( function( a, b ){
    return a - b;
   });
   // 输出: [ 1, 3, 4 ]
   //从大到小排列
   [ 1, 4, 3 ].sort( function( a, b ){
    return b - a;
   });
   // 输出: [ 4, 3, 1 ] 
   ```

   

### 函数作为返回值输出

1. 判断数据类型

   ```js
   var Type = {};
   for ( var i = 0, type; type = [ 'String', 'Array', 'Number' ][ i++ ]; ){
      (function( type ){
      Type[ 'is' + type ] = function( obj ){
      return Object.prototype.toString.call( obj ) === '[object '+ type +']';
      }
      })( type )
   };
   Type.isArray( [] ); // 输出：true
   Type.isString( "str" ); // 输出：true 
   ```

   

2. getSingle 

   下面是一个单例模式的例子

   ```js
    var getSingle = function ( fn ) { 
      var ret; 
      return function () { 
        return ret || ( ret = fn.apply( this, arguments ) );
      };
    };
   ```

   

    这个高阶函数的例子，既把函数当作参数传递，又让函数执行后返回了另外一个函数。

   我们 可以看看 getSingle 函数的效果： 

   ```js
   var getScript = getSingle(function(){
     return document.createElement( 'script' ); 
   }); 
   var script1 = getScript();
   var script2 = getScript(); 
   alert ( script1 === script2 ); // 输出：true 
   ```

   ##  高阶函数实现AOP(面向切面编程)

   通常，在 JavaScript 中实现 AOP，都是指把一个函数“动态织入”到另外一个函数之中，具 体的实现技术有很多，本节我们通过扩展 `Function.prototype` 来做到这一点。代码如下：

   ```js
   Function.prototype.before = function( beforefn ){
    var __self = this; // 保存原函数的引用
    return function(){ // 返回包含了原函数和新函数的"代理"函数
    beforefn.apply( this, arguments ); // 执行新函数，修正 this
    return __self.apply( this, arguments ); // 执行原函数
    }
   };
   Function.prototype.after = function( afterfn ){
    var __self = this;
    return function(){
    var ret = __self.apply( this, arguments );
    afterfn.apply( this, arguments );
    return ret;
    }
   };
   var func = function(){
    console.log( 2 );
   };
   func = func.before(function(){
    console.log( 1 );
   }).after(function(){
    console.log( 3 );
   });
   func(); 
   ```

   

   ### 函数柯里化（currying）

   > currying 又称部分求值。一个 currying 的函数首先会接受一些参数，接受了这些参数之后， 该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保 存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。
   
   ```js
   var currying = function (fn) {
     var args = [];
     return function callee() {
       if (arguments.length === 0) {
         return fn.apply(this, args);
       } else {
         [].push.apply(args, arguments);
         // callee 是 arguments 对象的一个属性。它可以用于引用该函数的函数体内当前正在执行的函数。
         // 在严格模式下，(ES5) 禁止使用 arguments.callee()。
         // return arguments.callee
         return callee
       }
     }
   
   };
   var cost = (function () {
     var money = 0;
    return function () {
       for (var i = 0, l = arguments.length; i < l; i++) {
         money += arguments[i];
       }
       return money;
     }
   })();
   var cost = currying(cost); // 转化成 currying 函数
   cost(100); // 未真正求值
   cost(200); // 未真正求值
   cost(300); // 未真正求值
   log(cost()); // 求值并输出：600 
   ```
   
   

### uncurrying

> 在 JavaScript 中，当我们调用对象的某个方法时，其实不用去关心该对象原本是否被设计为 拥有这个方法
>
> 同理，一个对象也未必只能使用它自身的方法，那么有什么办法可以让对象去借用一个原本 不属于它的方法呢？
>
> call 和 apply 都可以完成这个需求

```js
(function(){
 Array.prototype.push.call( arguments, 4 ); // arguments 借用 Array.prototype.push 方法
 console.log( arguments ); // 输出：[1, 2, 3, 4]
})( 1, 2, 3 );
```

在我们的预期中，Array.prototype 上的方法原本只能用来操作 array 对象。但用 call 和 apply 可以把任意对象当作 this 传入某个方法，这样一来，方法中用到 this 的地方就不再局限于原来 规定的对象，而是加以泛化并得到更广的适用性。 

**uncurrying**

```js
Function.prototype.uncurrying = function () {
 var self = this; // self 此时是 Array.prototype.push
 return function() {
 var obj = Array.prototype.shift.call( arguments );
 // obj 是{
 // "length": 1,
 // "0": 1
 // }
 // arguments 对象的第一个元素被截去，剩下[2]
 return self.apply( obj, arguments );
 // 相当于 Array.prototype.push.apply( obj, 2 )
 };
};
var push = Array.prototype.push.uncurrying();
var obj = {
 "length": 1,
 "0": 1
};
push( obj, 2 );
console.log( obj ); // 输出：{0: 1, 1: 2, length: 2} 

// or
Function.prototype.uncurrying = function(){
 var self = this;
 return function(){
 return Function.prototype.call.apply( self, arguments );
 }
}; 
```

### 函数节流

> 降低事件触发的频率

```js
var throttle = function (fn, interval) {
  var __self = fn, // 保存需要被延迟执行的函数引用
      timer, // 定时器
      firstTime = true; // 是否是第一次调用
  return function () {
    var args = arguments,
        __me = this;
    if (firstTime) { // 如果是第一次调用，不需延迟执行
      __self.apply(__me, args);
      return firstTime = false;
    }
    if (timer) { // 如果定时器还在，说明前一次延迟执行还没有完成
      return false;
    }
    timer = setTimeout(function () { // 延迟一段时间执行
      clearTimeout(timer);
      timer = null;
      __self.apply(__me, args);
    }, interval || 500);
  };
};
window.onresize = throttle(function () {
  console.log(1);
}, 500);
```

### 分时函数

> 将短时间内的大量操作分时分批次操作

```js
var timeChunk = function( ary, fn, count ){
 var obj,
 t;
 var len = ary.length;
 var start = function(){
 for ( var i = 0; i < Math.min( count || 1, ary.length ); i++ ){
 var obj = ary.shift();
 fn( obj );
 }
 };
 return function(){
 t = setInterval(function(){
 if ( ary.length === 0 ){ // 如果全部节点都已经被创建好
 return clearInterval( t );
 }
 start();
 }, 200 ); // 分批执行的时间间隔，也可以用参数的形式传入
 };
}; 
```

###  惰性加载函数

> 在 Web 开发中，因为浏览器之间的实现差异，一些嗅探工作总是不可避免。比如我们需要 一个在各个浏览器中能够通用的事件绑定函数 addEvent

addEvent 在函数里依然有一些分支判断。但是在第一次进入条件分支之后，在函数内部会重写这个函 数，重写之后的函数就是我们期望的 addEvent 函数，在下一次进入 addEvent 函数的时候，addEvent 函数里不再存在条件分支语句： 

```js
        var addEvent = function (elem, type, handler) {
            if (window.addEventListener) {
                addEvent = function (elem, type, handler) {
                    elem.addEventListener(type, handler, false);
                }
            } else if (window.attachEvent) {
                addEvent = function (elem, type, handler) {
                    elem.attachEvent('on' + type, handler);
                }
            }
            addEvent(elem, type, handler);
        };
```

